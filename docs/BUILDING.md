# scm-1-delay @ d8euAI8sMs

Проект представляет собой попытку использования языка Haskell для решения прикладных задач. Поскольку автор не силен в Haskell, тем более мало представляет, как разрабатывать GUI (графики, окна, кнопки, события и т.д.) на чистом Haskell, а также чисто ради интереса попробовать оссуществить хороший interop между Haskell и C/C++, было решено разрабатывать графику на MFC, а логику на Haskell.

Данное решените породило массу проблем, особенно в свете того, что разработка велась на Windows. Простейшие следствия Windows:

* Библиотеки и все пракеты собраны как статические. Для Windows невозможно собрать GHC с динамической линковкой в принципе. Отсюда -- невозможность вызывать Haskell из C++ на Windows: нереально прилинковаться правильно к сотне статических библиотек (+ библиотеки MSYS и GCC будут конфликтовать с оными от MSVC).
* Проблемы с путями и проч. (процессы Windows и т.д.) со стороны Haskell/Stack/etc. Невозможно из `Setup.hs` запустить `msbuild` -- он просто не запускается. Потому как главная система сборки выступает `msbuild`.
* Stack и `msbuild` имеют разные представления о профилях сборки, в разных местах хранят результаты сборки. Stack ожидает, что библиотека установлена в системе! Потому, чтобы это обойти, приходится складывать `.dll`-ки непосредственно в рабочий каталог Stack (корень проекта на Haskell). Аналогично приходится поступать с `.lib`. Причем этого можно было бы измежать, если бы все редактировалось в Visual Studio и хорошо запускалось бы из нее самой. Однако код на Haskell приходится писать в vscode (с плагином hie -- Haskell Ide Engine), а код на С++ -- в vs201x. Потому вместо сборки отдельной версии (архитектуры и т.д.) в отдельной директории `$(TargetDir)` сборка Stack-ом происходит в корне проекта на Haskell. Сюда же Windows-специфичное ограничение, что сборка вне корня Haskell-проекта не возможна!
* Stack не любит пути Windows, потому пробелы запрещены. Можно было бы добавить преобразование Windows-Unix путей через `cygpath`, но для этого он обязан присутствовать в `PATH`.
* Линкер vs201x геренирует не полностью совместимые с GCC `.lib`-файлы. Для генерации совместимых приходится прогонять `.dll`-ки через утилиты `gendef` (генерирует `.def`-файл) и `dlltool` (генерирует `.lib` по данному `.def`). Утилиты являются частью `MSYS` и должны быть в `PATH`.

Следует сказать еще пару слов:

* ~~Линкер vs201x генерирует GCC-совместимые `.lib`-файлы. Потому процесс сборки можно упростить. Иначе их бы пришлось генерировать руками (см. `.targets` главной `.dll`-ки).~~
* **UPD:** Сказанное верно только для экспортируемых функций без аргументов. См. выше.

## Сборка

Сборка из коробки работает из самой vs201x. Цели настроены таким образом, чтобы все работало автоматически. Даже отладка кода `.dll`-ки работает при запуске главного проекта. Хотя Stack дергается при каждой сборке кода.

Сборка Haskell-проекта отдельно также работает, однако предварительно следует запустить сборку из vs201x. Иначе у Stack-а не будет ни `.lib`, ни `.dll`.

Результат сборки будет располагаться в `$(TargetDir)`. Оттуда он должен запускаться нормально.

**UPD:** Отладка работает крайне странно. При сборке в Debug отладчик ругается на отсутствие некоторых функций и не запускается вовсе. Если реализации функций тоже (наряду с заголовочником) пометить как `extern "C"`, ругаться перестает, но не останавливается на точках останова, мотивируя это тем, что "исходники не совпадают" (с чем?). В Release тоже не все гладко. Заходит во все внешние функции, но в (некоторые?) виртуальные не заходит в принципе. Это в принципе не самая большая проблема, да и пользоваться отладкой в GUI вряд ли необходимо, однако она сильно напрягает "эстетически".

## Инструменты

Для сборки проекта необходимы:

* `Visual Studio 2019 >= Community Edition`
* `Stack` with snapshot `lts-14.6` (`GHC 8.6.5`)
* `c2hs` (type `stack install c2hs` to install it)
* `MSYS MINGW64` (with `bin` directory in `PATH`)
    - `gendef`
    - `dlltool`

`c2hs` необходим для упрощения жизни при генерации оберток для нативных функций. Он автоматически начинает участвовать в сборке, если установлен через `Stack`.

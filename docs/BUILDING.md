# scm-1-delay @ d8euAI8sMs

Проект представляет собой попытку использования языка Haskell для решения прикладных задач. Поскольку автор не силен в Haskell, тем более мало представляет, как разрабатывать GUI (графики, окна, кнопки, события и т.д.) на чистом Haskell, а также чисто ради интереса попробовать оссуществить хороший interop между Haskell и C/C++, было решено разрабатывать графику на MFC, а логику на Haskell.

Данное решените породило массу проблем, особенно в свете того, что разработка велась на Windows. Простейшие следствия Windows:

* Библиотеки и все пракеты собраны как статические. Для Windows невозможно собрать GHC с динамической линковкой в принципе. Отсюда -- невозможность вызывать Haskell из C++ на Windows: нереально прилинковаться правильно к сотне статических библиотек (+ библиотеки MSYS и GCC будут конфликтовать с оными от MSVC).
* Проблемы с путями и проч. (процессы Windows и т.д.) со стороны Haskell/Stack/etc. Невозможно из `Setup.hs` запустить `msbuild` -- он просто не запускается. Потому как главная система сборки выступает `msbuild`.
* Stack и `msbuild` имеют разные представления о профилях сборки, в разных местах хранят результаты сборки. Stack ожидает, что библиотека установлена в системе! Потому, чтобы это обойти, приходится складывать `.dll`-ки непосредственно в рабочий каталог Stack (корень проекта на Haskell). Аналогично приходится поступать с `.lib`. Причем этого можно было бы измежать, если бы все редактировалось в Visual Studio и хорошо запускалось бы из нее самой. Однако код на Haskell приходится писать в vscode (с плагином hie -- Haskell Ide Engine), а код на С++ -- в vs201x. Потому вместо сборки отдельной версии (архитектуры и т.д.) в отдельной директории `$(TargetDir)` сборка Stack-ом происходит в корне проекта на Haskell. Сюда же Windows-специфичное ограничение, что сборка вне корня Haskell-проекта не возможна!
* Stack не любит пути Windows, потому пробелы запрещены. Можно было бы добавить преобразование Windows-Unix путей через `cygpath`, но для этого он обязан присутствовать в `PATH`.

Следует сказать еще пару слов:

* Линкер vs201x генерирует GCC-совместимые `.lib`-файлы. Потому процесс сборки можно упростить. Иначе их бы пришлось генерировать руками (см. `.targets` главной `.dll`-ки).

## Сборка

Сборка из коробки работает из самой vs201x. Цели настроены таким образом, чтобы все работало автоматически. Даже отладка кода `.dll`-ки работает при запуске главного проекта. Хотя Stack дергается при каждой сборке кода.

Сборка Haskell-проекта отдельно также работает, однако предварительно следует запустить сборку из vs201x. Иначе у Stack-а не будет ни `.lib`, ни `.dll`.

Результат сборки будет располагаться в `$(TargetDir)`. Оттуда он должен запускаться нормально.
